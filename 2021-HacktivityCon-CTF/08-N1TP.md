![](images/8-header.png)

# N1TP
### easy | cryptography | 50 points
<br/>

## Challenge Information
These warmups are just too easy! This one definitely starts that way, at least!
<br/><br />

## Solution

On connecting to the server, the following text is shown:
```shell
piyagehi@Piyas-MacBook-Pro:~$ nc challenge.ctf.games 32315
NINA: Hello! I found a flag, look!
dc0de91facbe90ee6f652167906ee0d17123cf9e746a63db4b4e7d93040f59331ead9be0b2fe
NINA: But I encrypted it with a very special nonce, the same length as the flag! I heard people say this encryption method is unbreakable! I'll even let you encrypt something to prove it!! What should we encrypt?
```

I tried various inputs, but nothing struck until I typed one of the flags from the other challenges as input.

```shell
flag{e04f962d0529a4289a685112bfldcdd3}
NINA: Ta-daaa!! I think this is called a 'one' 'time' 'pad' or something?
dc0de91face292ed3f3f7337c368b4d02c26cdce7d3537df40497c9b5509063c4aafceb5e3fe
NINA: Isn't that cool!?! Want to see it again?
Sorry, I forget already what was it you wanted to see again?
```

The first few characters of the ciphertext of the flag and the input I gave are very similar. So there has to be some common value.

After a while, my notice went towards the words "One time pad". Immediately went to google and find out possible solutions.

I was reminded of an attack called the "Known Plaintext Attack" which I had learnt in a network security class last year. 
> If the ciphertext and its corresponding plaintext is known, the one time pad can easily be retrieved by XORing the plaintext and ciphertext.

Having only learnt the theory to this, I wasn't sure how to actually XOR two values of different lengths and encodings (plaintext is in ascii, ciphertext is in hex). So off I went to Google again to look for any help on this.

I ended up finding a writeup for a very similar CTF challenge! - [CR2-Many time secrets - AlexCTF 2017](https://ctftime.org/writeup/5589)

This particular writeup used a tool called [cribdrag](https://github.com/SpiderLabs/cribdrag), which includes a python script called [xorstrings.py](https://github.com/SpiderLabs/cribdrag/blob/master/xorstrings.py). This is exactly what I needed to complete this challenge!

I modified xorstrings.py to suit this challenge, by changing the parameters (s1 and s2) to the plaintext and ciphertext respectively. 

```python
#!/usr/bin/python

##########################
# cribdrag - An interactive crib dragging tool
# Daniel Crowley
# Copyright (C) 2013 Trustwave Holdings, Inc.
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
##########################

import sys
import argparse

def sxor(s1,s2):    
    # convert strings to a list of character pair tuples
    # go through each tuple, converting them to ASCII code (ord)
    # perform exclusive or on the ASCII code
    # then convert the result back to ASCII (chr)
    # merge the resulting array of characters as a string
    return ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(s1,s2))

parser = argparse.ArgumentParser(description='xorstrings is a utility which comes with cribdrag, the interactive crib dragging tool. xorstrings takes two ASCII hex encoded strings and XORs them together. This can be useful when cryptanalyzing ciphertext produced by the One Time Pad algorithm or a stream cipher when keys are reused, as one can XOR two ciphertexts together and then crib drag across the result, which is both plaintexts XORed together.')
parser.add_argument('data1', help='Data encoded in an ASCII hex format (ie. ABC would be 414243)')
parser.add_argument('data2', help='Data encoded in an ASCII hex format (ie. ABC would be 414243)')
args = parser.parse_args()

s1 = "dc0de91face292ed3f3f7337c368b4d02c26cdce7d3537df40497c9b5509063c4aafceb5e3fe".decode('hex')
s2 = "flag{e04f962d0529a4289a685112bfldcdd3}"

s3 = sxor(s1, s2)

print s3
```

Running this returns the one-time-pad as output.

Then I modified xorstrings.py again, this time changing the parameters to the one time pad and the flag's ciphertext.

Running this returns the flag for the challenge!