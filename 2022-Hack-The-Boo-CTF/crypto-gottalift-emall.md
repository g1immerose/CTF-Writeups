# Gonna-Lift-Em-All
easy | crypto | 200pts

>Quick, there's a new custom Pokemon in the bush called "The Custom Pokemon". Can you find out what its weakness is and capture it?

## First Impressions

The challenge comes with two files, `chall.py` and `data.txt`

```python
from Crypto.Util.number import bytes_to_long, getPrime
import random

FLAG = b'HTB{??????????????????????????????????????????????????????????????????????}'

def gen_params():
  p = getPrime(1024)
  g = random.randint(2, p-2)
  x = random.randint(2, p-2)
  h = pow(g, x, p)
  return (p, g, h), x

def encrypt(pubkey):
  p, g, h = pubkey
  m = bytes_to_long(FLAG)
  y = random.randint(2, p-2)
  s = pow(h, y, p)
  return (g * y % p, m * s % p)

def main():
  pubkey, privkey = gen_params()
  c1, c2 = encrypt(pubkey)

  with open('data.txt', 'w') as f:
    f.write(f'p = {pubkey[0]}\ng = {pubkey[1]}\nh = {pubkey[2]}\n(c1, c2) = ({c1}, {c2})\n')


if __name__ == "__main__":
  main()
```

The python script generates two ciphertexts, using various [modular arithmetic](https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic) operations, more specifically moduluar multiplication. The script writes the values of the public key (`p`,`g`,`h`) and the two ciphertexts to a file, which is `data.txt`

```txt
p = 163096280281091423983210248406915712517889481034858950909290409636473708049935881617682030048346215988640991054059665720267702269812372029514413149200077540372286640767440712609200928109053348791072129620291461211782445376287196340880230151621619967077864403170491990385250500736122995129377670743204192511487
g = 90013867415033815546788865683138787340981114779795027049849106735163065530238112558925433950669257882773719245540328122774485318132233380232659378189294454934415433502907419484904868579770055146403383222584313613545633012035801235443658074554570316320175379613006002500159040573384221472749392328180810282909
h = 36126929766421201592898598390796462047092189488294899467611358820068759559145016809953567417997852926385712060056759236355651329519671229503584054092862591820977252929713375230785797177168714290835111838057125364932429350418633983021165325131930984126892231131770259051468531005183584452954169653119524751729
(c1, c2) = (159888401067473505158228981260048538206997685715926404215585294103028971525122709370069002987651820789915955483297339998284909198539884370216675928669717336010990834572641551913464452325312178797916891874885912285079465823124506696494765212303264868663818171793272450116611177713890102083844049242593904824396, 119922107693874734193003422004373653093552019951764644568950336416836757753914623024010126542723403161511430245803749782677240741425557896253881748212849840746908130439957915793292025688133503007044034712413879714604088691748282035315237472061427142978538459398404960344186573668737856258157623070654311038584)
```

The second ciphertext contains the flag, we can retrieve it based on the values given.

## Solution

```python
# Snippet from the encrypt() function
s = pow(h, y, p)
return (g * y % p, m * s % p) # (c1, c2)
```

Since we have the values of `g`, `p` and `c1`, we can calculate `y`. Now that we have `y`, we can calculate `s` from `h`,`y` and `p`. Finally, we calculate `m` or the flag with `s`, `p` and `c2`.

Beginning with the first step, calculating `y`. If this were regular multiplication (without mod p), y would be equal to `c1/g`. However, the opposite of multiplication in modular arithmetic is the [moduluar inverse](https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-inverses), which makes the formula `y = (g^-1 * c1) mod p`. I wrote a python script to solve this, so the python equivalent to this statement would be

```python
y = pow(g, -1, p) * c1 % p
```

Moving on to the calculation of `s`. The calcuation is already provided in the script, so the same statement is repeated

```python
s = pow(h, y, p)
```

Lastly, calculating `m` or the flag. This is similar to the first calculation, by calculating the modular inverse of `s` multiplied by the ciphertext

```python
m = pow(s, -1, p) * c2 % p
```

As the final message is a huge number, I added a line in the end to convert [this integer to its string form](https://stackoverflow.com/a/42498359). Here's the complete script

```python
FLAG = b'HTB{??????????????????????????????????????????????????????????????????????}'

p = 163096280281091423983210248406915712517889481034858950909290409636473708049935881617682030048346215988640991054059665720267702269812372029514413149200077540372286640767440712609200928109053348791072129620291461211782445376287196340880230151621619967077864403170491990385250500736122995129377670743204192511487
g = 90013867415033815546788865683138787340981114779795027049849106735163065530238112558925433950669257882773719245540328122774485318132233380232659378189294454934415433502907419484904868579770055146403383222584313613545633012035801235443658074554570316320175379613006002500159040573384221472749392328180810282909
h = 36126929766421201592898598390796462047092189488294899467611358820068759559145016809953567417997852926385712060056759236355651329519671229503584054092862591820977252929713375230785797177168714290835111838057125364932429350418633983021165325131930984126892231131770259051468531005183584452954169653119524751729
c1 = 159888401067473505158228981260048538206997685715926404215585294103028971525122709370069002987651820789915955483297339998284909198539884370216675928669717336010990834572641551913464452325312178797916891874885912285079465823124506696494765212303264868663818171793272450116611177713890102083844049242593904824396
c2 = 119922107693874734193003422004373653093552019951764644568950336416836757753914623024010126542723403161511430245803749782677240741425557896253881748212849840746908130439957915793292025688133503007044034712413879714604088691748282035315237472061427142978538459398404960344186573668737856258157623070654311038584

y = pow(g, -1, p) * c1 % p
s = pow(h, y, p)
flag = pow(s, -1, p) * c2 % p
nchars = len(FLAG)
print(''.join(chr((flag>>8*(nchars-byte-1))&0xFF) for byte in range(nchars)))
```

```txt
$ python3 gonnaliftemall-sol.py
HTB{b3_c4r3ful_wh3n_1mpl3m3n71n6_cryp705y573m5_1n_7h3_mul71pl1c471v3_6r0up}
```

Flag: `HTB{b3_c4r3ful_wh3n_1mpl3m3n71n6_cryp705y573m5_1n_7h3_mul71pl1c471v3_6r0up}`